% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spectrogram_images.R
\name{spectrogram_images}
\alias{spectrogram_images}
\title{Process and Save Spectrogram Images from Sound Files}
\usage{
spectrogram_images(
  trainingBasePath,
  outputBasePath,
  splits,
  random = "FALSE",
  minfreq.khz = 0.4,
  maxfreq.khz = 1.6,
  new.sampleratehz = 16000
)
}
\arguments{
\item{trainingBasePath}{Base directory containing the training folders.}

\item{outputBasePath}{Directory where the processed images will be saved.}

\item{splits}{Numeric vector specifying the split ratios for train, valid, and test sets. Defaults to c(0.8, 0.1, 0.1).}

\item{random}{Logical. If TRUE then randomly samples from folder, if FALSE then divides into sets based on alphabetic file name sequence.}

\item{minfreq.khz}{Minimum frequency in kHz for the spectrogram. Defaults to 0.4.}

\item{maxfreq.khz}{Maximum frequency in kHz for the spectrogram. Defaults to 2.}

\item{new.sampleratehz}{New sample rate in Hz for resampling the audio. Defaults to 16000. Set to 'NA' if no resampling is required.}
}
\value{
Invisible NULL
}
\description{
Process and Save Spectrogram Images from Sound Files
}
\examples{
{
#' # Load the 'TempBinWav' data
data("TempBinWav")

#' # Define the output directory for saving .wav files
output.dir <- file.path(tempdir(), 'MultiDir', 'Soundfiles', 'Noise')

#' # Create the output directory if it doesn't already exist
dir.create(output.dir, recursive = TRUE, showWarnings = FALSE)

#' # Define the intervals for cutting the wave (from 1 to 30 with a step of 5)
cutwave.list <- seq(1, 30, 5)

#' # Extract subsamples from the waveform by looping through the cutwave intervals
subsamps <- lapply(1:(length(cutwave.list) - 1),
                   function(i)
                     extractWave(
                       TempBinWav,         # Input waveform data
                       from = cutwave.list[i],  # Start point of the cut interval
                       to = cutwave.list[i + 1], # End point of the cut interval
                       xunit = "time",     # Specify the unit as time
                       plot = FALSE,       # Don't plot the waveform
                       output = "Wave"     # Specify the output type (Wave)
                     ))

#' # Write the extracted subsamples to .wav files in the defined output directory
lapply(1:length(subsamps),
       function(i)
         writeWave(
           subsamps[[i]],  # Subsample to save
           filename = file.path(output.dir, paste('temp_', i, '_', '.wav', sep = '')),  # File path with a dynamic naming pattern
           extensible = FALSE  # Disable extensible wave format
         )
)

#' # List all the files in the output directory
list.files(output.dir)

#' # Generate spectrogram images for sound files located in 'Soundfiles' directory
spectrogram_images(
  trainingBasePath = file.path(tempdir(), 'MultiDir/Soundfiles/'),  # Base path for input sound files
  outputBasePath = file.path(tempdir(), 'MultiDir/', 'Spectro'),  # Base path for saving generated spectrogram images
  splits = c(0.5, 0.5, 0.0),  # Split the data into training (50\%), validation (50\%), and no test data (0\%)
  new.sampleratehz = 'NA'  # No change to the sampling rate
)

#' # List all the images generated by the spectrogram process
ListImages <- list.files(file.path(tempdir(), 'MultiDir/', 'Spectro'), recursive = TRUE)
print(ListImages)

#' # Get the path of a single spectrogram image
Singlepath <- list.files(file.path(tempdir(), 'MultiDir', 'Spectro'), recursive = TRUE, full.names = TRUE)[1]

#' # Set input data path for the training images
input.data.path <- file.path(tempdir(), 'MultiDir', 'Spectro', 'train')

#' # Load images from the directory and apply transformations for model input
train_ds <- image_folder_dataset(
  file.path(input.data.path),   # Path to the directory containing training images
  transform = . \%>\%
    torchvision::transform_to_tensor() \%>\%  # Convert the images to tensor format
    torchvision::transform_resize(size = c(224, 224)) \%>\%  # Resize all images to 224x224 pixels
    torchvision::transform_normalize(  # Normalize the images using standard mean and standard deviation values
      mean = c(0.485, 0.456, 0.406),  # Mean values for normalization
      std = c(0.229, 0.224, 0.225)    # Standard deviation values for normalization
    ),
  target_transform = function(x) as.double(x) - 1  # Transform the target labels (classes)
)

#' # Create a dataloader from the dataset with specified batch size, no shuffling
train_dl <- dataloader(train_ds, batch_size = train_ds$.length(), shuffle = FALSE, drop_last = TRUE)

#' # Extract the next batch from the dataloader
batch <- train_dl$.iter()$.next()

#' # Extract the labels for the batch and determine class names from the folder structure
classes <- batch[[2]]
class_names <- list.files(input.data.path, recursive = TRUE)  # Get class names from subfolder names
class_names <- str_split_fixed(class_names, pattern = '/', n = 2)[, 1]  # Extract the class name (folder name)

#' # Convert the batch tensor of images to an array and reorder dimensions for processing
images <- as_array(batch[[1]]) \%>\% aperm(perm = c(1, 3, 4, 2))

#' # Set the plotting parameters for displaying images
par(mfcol = c(3, 4), mar = rep(1, 4))

#' # Define a function to normalize pixel values in an image (scaling pixel values between 0 and 1)
normalize_pixel_values <- function(image) {
  normalized_image <- (image - min(image)) / (max(image) - min(image))  # Normalize the image
  return(normalized_image)
}

#' # Display the images after normalizing them, with titles for each class
images \%>\%
  purrr::array_tree(1) \%>\%
  purrr::set_names(class_names) \%>\%
  purrr::map(~ as.raster(normalize_pixel_values(.x))) \%>\%
  purrr::iwalk(~ {plot(.x); title(.y)})  # Plot the image with its respective class name as title
}

}
