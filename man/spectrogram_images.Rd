% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spectrogram_images.R
\name{spectrogram_images}
\alias{spectrogram_images}
\title{Process and Save Spectrogram Images from Sound Files}
\usage{
spectrogram_images(
  trainingBasePath,
  outputBasePath,
  splits,
  random = "TRUE",
  minfreq.khz = 0.4,
  maxfreq.khz = 1.6,
  new.sampleratehz = 16000
)
}
\arguments{
\item{trainingBasePath}{Base directory containing the training folders.}

\item{outputBasePath}{Directory where the processed images will be saved.}

\item{splits}{Numeric vector specifying the split ratios for train, valid, and test sets. Defaults to c(0.8, 0.1, 0.1).}

\item{random}{Logical. If TRUE then randomly samples from folder, if FALSE then divides into sets based on alphabetic file name sequence.}

\item{minfreq.khz}{Minimum frequency in kHz for the spectrogram. Defaults to 0.4.}

\item{maxfreq.khz}{Maximum frequency in kHz for the spectrogram. Defaults to 2.}

\item{new.sampleratehz}{New sample rate in Hz for resampling the audio. Defaults to 16000. Set to 'NA' if no resampling is required.}
}
\value{
Invisible NULL
}
\description{
Process and Save Spectrogram Images from Sound Files
}
\examples{
{
if (.Platform$OS.type == "unix") {
# Load the gibbonNetR package
library(gibbonNetR)
library(torchvision)
library(torch)

# Load data
data("TempBinWav")

# Define the output directory
output.dir <- paste(tempdir(), '/MultiDir/Noise/')

# Create the output directory
dir.create(output.dir, recursive = TRUE, showWarnings = FALSE)

# Define the intervals for cutting the wave
cutwave.list <- seq(1, 30, 5)

# Extract subsamples from the waveform
subsamps <- lapply(1:(length(cutwave.list) - 1),
                   function(i)
                     extractWave(
                       TempBinWav,
                       from = cutwave.list[i],
                       to = cutwave.list[i + 1],
                       xunit = c("time"),
                       plot = FALSE,
                       output = "Wave"
                     ))

# Write the extracted subsamples to .wav files
lapply(1:length(subsamps),
       function(i)
         writeWave(
           subsamps[[i]],
           filename = paste(
             output.dir,
             'temp_', i, '_', '.wav',
             sep = ''
           ),
           extensible = FALSE
         )
)

# List the files in the output directory
list.files(output.dir)

# Generate spectrogram images
spectrogram_images(
  trainingBasePath = paste(tempdir(), '/MultiDir/'),
  outputBasePath = paste(tempdir(), '/MultiDir/', 'Spectro/', sep = ''),
  splits = c(1, 0, 0),
  new.sampleratehz = 'NA'
)

# List the images generated
ListImages <- list.files(paste(tempdir(), '/MultiDir/', 'Spectro/', sep = ''), recursive = TRUE)

print(ListImages)

# Get the path of a single image
Singlepath <- list.files(paste(tempdir(),
'/MultiDir/', 'Spectro/', sep = ''),
recursive = TRUE, full.names = TRUE)[1]

# Set input data path
input.data.path <- paste(tempdir(), '/MultiDir/', 'Spectro/train/', sep = '')

# Load images in path
train_ds <- image_folder_dataset(
  file.path(input.data.path),   #' Path to the image directory
  transform = . \%>\%
    torchvision::transform_to_tensor() \%>\%
    torchvision::transform_resize(size = c(224, 224)) \%>\%
    torchvision::transform_normalize(
      mean = c(0.485, 0.456, 0.406),      #' Mean for normalization
      std = c(0.229, 0.224, 0.225)        #' Standard deviation for normalization
    ),
  target_transform = function(x) as.double(x) - 1  #' Transformation for target/labels
)

# Create a dataloader from the dataset:
train_dl <- dataloader(train_ds, batch_size = train_ds$.length(), shuffle = FALSE, drop_last = TRUE)

# Extract the next batch from the dataloader
batch <- train_dl$.iter()$.next()

# Extract the labels for the batch and determine class names
classes <- batch[[2]]
class_names <- list.files(input.data.path,recursive = TRUE)
class_names <- str_split_fixed(class_names,pattern = '/',n=2)[,1]

# Convert the batch tensor of images to an array and process them:
images <- as_array(batch[[1]]) \%>\% aperm(perm = c(1, 3, 4, 2))

# Set the plotting parameters
par(mfcol = c(3,4), mar = rep(1, 4))

#Define a function to normalize pixel values
normalize_pixel_values <- function(image) {
  normalized_image <- (image - min(image)) / (max(image) - min(image))
  return(normalized_image)
}

images \%>\%
        purrr::array_tree(1) \%>\%
        purrr::set_names(class_names) \%>\%
        purrr::map(~ as.raster(normalize_pixel_values(.x))) \%>\%
        purrr::iwalk(~{plot(.x); title(.y)})
        }
        }
}
