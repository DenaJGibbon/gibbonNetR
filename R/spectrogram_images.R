#' Process and Save Spectrogram Images from Sound Files
#'
#' @param trainingBasePath Base directory containing the training folders.
#' @param outputBasePath Directory where the processed images will be saved.
#' @param splits Numeric vector specifying the split ratios for train, valid, and test sets. Defaults to c(0.8, 0.1, 0.1).
#' @param windowlength window length for input into 'spectro' function from seewave. Deafults to 512.
#' @param minfreq.khz Minimum frequency in kHz for the spectrogram. Defaults to 0.4.
#' @param maxfreq.khz Maximum frequency in kHz for the spectrogram. Defaults to 2.
#' @param new.sampleratehz New sample rate in Hz for resampling the audio. Defaults to 16000. Set to 'NA' if no resampling is required.
#' @param random Logical. If TRUE then randomly samples from folder, if FALSE then divides into sets based on alphabetic file name sequence.
#' @examples
#' {
#'   # Load the 'TempBinWav' data
#'   data("TempBinWav")
#'
#'   # Define the output directory for saving .wav files
#'   output.dir <- file.path(tempdir(), "MultiDir", "Soundfiles", "Noise")
#'
#'   # Create the output directory if it doesn't already exist
#'   dir.create(output.dir, recursive = TRUE, showWarnings = FALSE)
#'
#'   # Define the intervals for cutting the wave (from 1 to 30 with a step of 5)
#'   cutwave.list <- seq(1, 30, 5)
#'
#'   # Extract subsamples from the waveform
#'   subsamps <- lapply(1:(length(cutwave.list) - 1), function(i) {
#'     extractWave(
#'       TempBinWav,
#'       from = cutwave.list[i],
#'       to = cutwave.list[i + 1],
#'       xunit = "time",
#'       plot = FALSE,
#'       output = "Wave"
#'     )
#'   })
#'
#'   # Write the extracted subsamples to .wav files
#'   lapply(1:length(subsamps), function(i) {
#'     writeWave(
#'       subsamps[[i]],
#'       filename = file.path(output.dir, paste("temp_", i, "_", ".wav", sep = "")),
#'       extensible = FALSE
#'     )
#'   })
#'
#'   # List all the files in the output directory
#'   list.files(output.dir)
#'
#'   # Generate spectrogram images for sound files
#'   spectrogram_images(
#'     trainingBasePath = file.path(tempdir(), "MultiDir/Soundfiles/"),
#'     outputBasePath = file.path(tempdir(), "MultiDir/", "Spectro"),
#'     splits = c(0.5, 0.5, 0.0),
#'     new.sampleratehz = "NA"
#'   )
#'
#'   # List all the images generated by the spectrogram process
#'   ListImages <- list.files(file.path(tempdir(), "MultiDir/", "Spectro"), recursive = TRUE)
#'   print(ListImages)
#'
#'   # Get the path of a single spectrogram image
#'   Singlepath <- list.files(
#'     file.path(tempdir(), "MultiDir", "Spectro"),
#'     recursive = TRUE,
#'     full.names = TRUE
#'   )[1]
#'
#'   # Set input data path for the training images
#'   input.data.path <- file.path(tempdir(), "MultiDir", "Spectro", "train")
#'
#'   # Load images and apply transformations
#'   train_ds <- image_folder_dataset(
#'     file.path(input.data.path),
#'     transform = . %>%
#'       torchvision::transform_to_tensor() %>%
#'       torchvision::transform_resize(size = c(224, 224)) %>%
#'       torchvision::transform_normalize(
#'         mean = c(0.485, 0.456, 0.406),
#'         std = c(0.229, 0.224, 0.225)
#'       ),
#'     target_transform = function(x) as.double(x) - 1
#'   )
#'
#'   # Create a dataloader
#'   train_dl <- torch::dataloader(train_ds,
#'   batch_size = train_ds$.length(),
#'   shuffle = FALSE, drop_last = TRUE)
#'
#'   # Extract the next batch from the dataloader
#'   batch <- train_dl$.iter()$.next()
#'
#'   # Extract the labels for the batch
#'   classes <- batch[[2]]
#'   class_names <- list.files(input.data.path, recursive = TRUE)
#'   class_names <- stringr::str_split_fixed(class_names, pattern = "/", n = 2)[, 1]
#'
#'   # Convert batch tensor of images to an array and reorder dimensions
#'   images <- torch::as_array(batch[[1]]) %>% aperm(perm = c(1, 3, 4, 2))
#'
#'   # Define a function to normalize pixel values
#'   normalize_pixel_values <- function(image) {
#'     (image - min(image)) / (max(image) - min(image))
#'   }
#'
#'   # Set plotting parameters
#'   par(mfcol = c(3, 4), mar = rep(1, 4))
#'
#'   # Display the images after normalizing, with titles for each class
#'   images <- images %>%
#'     purrr::array_tree(1) %>%
#'     purrr::set_names(class_names) %>%
#'     purrr::map(~ as.raster(normalize_pixel_values(.x)))
#'
#'   purrr::iwalk(images, ~ {
#'     plot(.x)
#'     title(.y)
#'   })
#' }
#' @return The function saves spectrogram images to train, valid, or test folders to the specified 'outputBasePath'.
#' \itemize{
#'   \item \strong{Folders with spectrogram images}: Depending on specified splits.
#' }
#' @importFrom tuneR readWave
#' @importFrom seewave spectro
#' @importFrom tools file_path_sans_ext
#' @importFrom stringr str_split_fixed
#' @importFrom torch dataloader as_array
#' @export

spectrogram_images <- function(trainingBasePath,
                               outputBasePath,
                               splits,
                               random = "FALSE",
                               windowlength=512,
                               minfreq.khz = 0.4,
                               maxfreq.khz = 1.6,
                               new.sampleratehz = 16000) {
  # Check if splits are valid
  if (sum(splits) != 1) {
    stop("The sum of the splits must equal 1.")
  }
  if (length(splits) != 3) {
    stop("Exactly three split ratios should be provided.")
  }

  # Lists all training folders
  TrainingFolders <- list.files(trainingBasePath, full.names = TRUE)

  TrainingFoldersShort <-
    list.files(trainingBasePath, full.names = FALSE)

  FolderVec <-
    c("train", "valid", "test") # Potential folders for classification

  for (z in seq_along(TrainingFolders)) {
    SoundFiles <-
      list.files(TrainingFolders[z],
        recursive = TRUE,
        full.names = TRUE
      )

    SoundFilesShort <-
      list.files(TrainingFolders[z],
        recursive = TRUE,
        full.names = FALSE
      )

    total_files <- length(SoundFiles)

    # Calculate indices for splitting
    # Shuffle indices
    if (random == "TRUE") {
      shuffled_indices <- sample(1:total_files)
    }

    if (random == "FALSE") {
      shuffled_indices <- seq(1:total_files)
    }

    # Calculate indices for splitting
    train_n <- floor(splits[1] * total_files)
    valid_n <- floor(splits[2] * total_files)

    if (splits[1] == 0) {
      train_idx <- 0
    } else {
      train_idx <- shuffled_indices[1:train_n]
    }

    if (splits[2] == 0) {
      valid_idx <- 0
    } else {
      valid_idx <- shuffled_indices[(train_n + 1):(train_n + valid_n)]
    }

    if (splits[3] == 0) {
      test_idx <- 0
    } else {
      test_idx <- setdiff(shuffled_indices, c(train_idx, valid_idx))
    }

    message("Creating spectrogram images")
    for (y in 1:length(SoundFilesShort)) {  tryCatch({
      # Determine the DataType based on the index
      if (y %in% train_idx) {
        DataType <- FolderVec[1]
      } else if (y %in% valid_idx) {
        DataType <- FolderVec[2]
      } else if (y %in% test_idx) {
        DataType <- FolderVec[3]
      }

      subset_directory <-
        file.path(outputBasePath, DataType, TrainingFoldersShort[z])

      if (!dir.exists(subset_directory)) {
        dir.create(subset_directory, recursive = TRUE)
        message("Created output dir: ", subset_directory)
      }

      wav_rm <- tools::file_path_sans_ext(SoundFilesShort[y])

      jpeg_filename <-
        file.path(subset_directory, paste0(wav_rm, ".jpg"))

      grDevices::jpeg(jpeg_filename, res = 50)

      short_wav <- tuneR::readWave(SoundFiles[y])

      if (new.sampleratehz != "NA") {
        short_wav <- tuneR::downsample(short_wav, new.sampleratehz)
      }

      seewave::spectro(
        short_wav,
        tlab = "",
        flab = "",
        wl = windowlength,
        axisX = FALSE,
        axisY = FALSE,
        scale = FALSE,
        flim = c(minfreq.khz, maxfreq.khz),
        grid = FALSE
      )
      graphics.off()
    }, error = function(e) {
      cat("ERROR :", conditionMessage(e), basename(SoundFilesShort[y]), "\n")
    })
    }
  }

  invisible(NULL)
}
