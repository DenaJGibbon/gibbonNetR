#' Process and Save Spectrogram Images from Sound Files
#'
#' @param trainingBasePath Base directory containing the training folders.
#' @param outputBasePath Directory where the processed images will be saved.
#' @param splits Numeric vector specifying the split ratios for train, valid, and test sets. Defaults to c(0.8, 0.1, 0.1).
#' @param minfreq.khz Minimum frequency in kHz for the spectrogram. Defaults to 0.4.
#' @param maxfreq.khz Maximum frequency in kHz for the spectrogram. Defaults to 2.
#' @param new.sampleratehz New sample rate in Hz for resampling the audio. Defaults to 16000. Set to 'NA' if no resampling is required.
#' @param random Logical. If TRUE then randomly samples from folder, if FALSE then divides into sets based on alphabetic file name sequence.
#' @return Invisible NULL
#' @examples
#' {
#' #' # Load the 'TempBinWav' data
#' data("TempBinWav")
#'
#' #' # Define the output directory for saving .wav files
#' output.dir <- file.path(tempdir(), 'MultiDir', 'Soundfiles', 'Noise')
#'
#' #' # Create the output directory if it doesn't already exist
#' dir.create(output.dir, recursive = TRUE, showWarnings = FALSE)
#'
#' #' # Define the intervals for cutting the wave (from 1 to 30 with a step of 5)
#' cutwave.list <- seq(1, 30, 5)
#'
#' #' # Extract subsamples from the waveform by looping through the cutwave intervals
#' subsamps <- lapply(1:(length(cutwave.list) - 1),
#'                    function(i)
#'                      extractWave(
#'                        TempBinWav,         # Input waveform data
#'                        from = cutwave.list[i],  # Start point of the cut interval
#'                        to = cutwave.list[i + 1], # End point of the cut interval
#'                        xunit = "time",     # Specify the unit as time
#'                        plot = FALSE,       # Don't plot the waveform
#'                        output = "Wave"     # Specify the output type (Wave)
#'                      ))
#'
#' #' # Write the extracted subsamples to .wav files in the defined output directory
#' lapply(1:length(subsamps),
#'        function(i)
#'          writeWave(
#'            subsamps[[i]],  # Subsample to save
#'            filename = file.path(output.dir, paste('temp_', i, '_', '.wav', sep = '')),  # File path with a dynamic naming pattern
#'            extensible = FALSE  # Disable extensible wave format
#'          )
#' )
#'
#' #' # List all the files in the output directory
#' list.files(output.dir)
#'
#' #' # Generate spectrogram images for sound files located in 'Soundfiles' directory
#' spectrogram_images(
#'   trainingBasePath = file.path(tempdir(), 'MultiDir/Soundfiles/'),  # Base path for input sound files
#'   outputBasePath = file.path(tempdir(), 'MultiDir/', 'Spectro'),  # Base path for saving generated spectrogram images
#'   splits = c(0.5, 0.5, 0.0),  # Split the data into training (50%), validation (50%), and no test data (0%)
#'   new.sampleratehz = 'NA'  # No change to the sampling rate
#' )
#'
#' #' # List all the images generated by the spectrogram process
#' ListImages <- list.files(file.path(tempdir(), 'MultiDir/', 'Spectro'), recursive = TRUE)
#' print(ListImages)
#'
#' #' # Get the path of a single spectrogram image
#' Singlepath <- list.files(file.path(tempdir(), 'MultiDir', 'Spectro'), recursive = TRUE, full.names = TRUE)[1]
#'
#' #' # Set input data path for the training images
#' input.data.path <- file.path(tempdir(), 'MultiDir', 'Spectro', 'train')
#'
#' #' # Load images from the directory and apply transformations for model input
#' train_ds <- image_folder_dataset(
#'   file.path(input.data.path),   # Path to the directory containing training images
#'   transform = . %>%
#'     torchvision::transform_to_tensor() %>%  # Convert the images to tensor format
#'     torchvision::transform_resize(size = c(224, 224)) %>%  # Resize all images to 224x224 pixels
#'     torchvision::transform_normalize(  # Normalize the images using standard mean and standard deviation values
#'       mean = c(0.485, 0.456, 0.406),  # Mean values for normalization
#'       std = c(0.229, 0.224, 0.225)    # Standard deviation values for normalization
#'     ),
#'   target_transform = function(x) as.double(x) - 1  # Transform the target labels (classes)
#' )
#'
#' #' # Create a dataloader from the dataset with specified batch size, no shuffling
#' train_dl <- dataloader(train_ds, batch_size = train_ds$.length(), shuffle = FALSE, drop_last = TRUE)
#'
#' #' # Extract the next batch from the dataloader
#' batch <- train_dl$.iter()$.next()
#'
#' #' # Extract the labels for the batch and determine class names from the folder structure
#' classes <- batch[[2]]
#' class_names <- list.files(input.data.path, recursive = TRUE)  # Get class names from subfolder names
#' class_names <- stringr::str_split_fixed(class_names, pattern = '/', n = 2)[, 1]  # Extract the class name (folder name)
#'
#' #' # Convert the batch tensor of images to an array and reorder dimensions for processing
#' images <- as_array(batch[[1]]) %>% aperm(perm = c(1, 3, 4, 2))
#'
#' #' # Define a function to normalize pixel values in an image (scaling pixel values between 0 and 1)
#' normalize_pixel_values <- function(image) {
#'   normalized_image <- (image - min(image)) / (max(image) - min(image))  # Normalize the image
#'   return(normalized_image)
#' }
#'
#' # Set the plotting parameters for displaying images
#' par(mfcol = c(3, 4), mar = rep(1, 4))
#'
#' #' # Display the images after normalizing them, with titles for each class
#' images <- images %>%
#'   purrr::array_tree(1) %>%
#'   purrr::set_names(class_names) %>%
#'   purrr::map(~ as.raster(normalize_pixel_values(.x))) %>%
#'   purrr::iwalk(~ {plot(.x); title(.y)})  # Plot the image with its respective class name as title
#'  purrr::iwalk(images, ~ {
#'  print(plot(.x))
#'  title(.y)
#'  })
#' }
#'
#' @importFrom tuneR readWave
#' @importFrom seewave spectro
#' @importFrom tools file_path_sans_ext
#' @importFrom stringr str_split_fixed
#' @export

spectrogram_images <- function(trainingBasePath,
                               outputBasePath,
                               splits,
                               random='FALSE',
                               minfreq.khz = 0.4,
                               maxfreq.khz = 1.6,
                               new.sampleratehz = 16000) {
  # Check if splits are valid
  if (sum(splits) != 1)
    stop("The sum of the splits must equal 1.")
  if (length(splits) != 3)
    stop("Exactly three split ratios should be provided.")

  # Lists all training folders
  TrainingFolders <- list.files(trainingBasePath, full.names = TRUE)

  TrainingFoldersShort <-
    list.files(trainingBasePath, full.names = FALSE)

  FolderVec <-
    c('train', 'valid', 'test') # Potential folders for classification

  for (z in seq_along(TrainingFolders)) {
    SoundFiles <-
      list.files(TrainingFolders[z],
                 recursive = TRUE,
                 full.names = TRUE)
    SoundFilesShort <-
      list.files(TrainingFolders[z],
                 recursive = TRUE,
                 full.names = FALSE)
    total_files <- length(SoundFiles)

    # Calculate indices for splitting
    # Shuffle indices
    if(random=='TRUE'){
    shuffled_indices <- sample(1:total_files)
    }

    if(random=='FALSE'){
      shuffled_indices <- seq(1:total_files)
    }

    # Calculate indices for splitting
    train_n <- floor(splits[1] * total_files)
    valid_n <- floor(splits[2] * total_files)

    train_idx <- shuffled_indices[1:train_n]

    valid_idx <- shuffled_indices[(train_n + 1):(train_n + valid_n)]

    test_idx <-
      shuffled_indices[-c(train_idx,valid_idx)]

    if (splits[1] == 0) {
      train_idx <- 0
    }

    if (splits[2] == 0) {
      valid_idx <- 0
    }

    if (splits[3] == 0) {
      test_idx <- 0
    }

    for (y in 1:length(SoundFiles)) {
      # Determine the DataType based on the index
      if (y %in% train_idx) {
        DataType <- FolderVec[1]
      } else if (y %in% valid_idx) {
        DataType <- FolderVec[2]
      } else if (y %in% test_idx) {
        DataType <- FolderVec[3]
      }

      subset_directory <-
        file.path(outputBasePath, DataType, TrainingFoldersShort[z])

      if (!dir.exists(subset_directory)) {
        dir.create(subset_directory, recursive = TRUE)
        message('Created output dir: ', subset_directory)
      } else {
        message(subset_directory,
                ' already exists saving spectrogram images')
      }

      wav_rm <- tools::file_path_sans_ext(SoundFilesShort[y])

      jpeg_filename <-
        file.path(subset_directory, paste0(wav_rm, '.jpg'))

      grDevices::jpeg(jpeg_filename, res = 50)

      short_wav <- tuneR::readWave(SoundFiles[y])

      if (new.sampleratehz != 'NA') {
        short_wav <- tuneR::downsample(short_wav, new.sampleratehz)
      }

      seewave::spectro(
        short_wav,
        tlab = '',
        flab = '',
        axisX = FALSE,
        axisY = FALSE,
        scale = FALSE,
        flim = c(minfreq.khz, maxfreq.khz),
        grid = FALSE
      )
      graphics.off()
    }
  }

  invisible(NULL)
}
